## 1.

Первый и наиболее распространенный случай — распространение ошибки, так что сбой в подпрограмме становится сбоем
вызывающей функции. Мы видели
162 ГЛАВА 5 ФУНКЦИИ
примеры этого в функции findLinks из раздела 5.3. Если вызов http.Get неудачен, findLinks передает ошибку HTTP
вызывающей функции без дальнейших церемоний:

```go
resp, err := http.Get(url)
if err != nil {
return nil, err
}
```

В противоположность этому, если неудачен вызов html.Parse, функция findLinks не возвращает ошибку HTML-анализатора
непосредственно, потому что в ней не хватает двух важнейших частей информации: того, что ошибка произошла в
синтаксическом анализаторе, и URL документа, анализ которого выполнялся. В этом случае функция findLinks создает новое
сообщение об ошибке, которое включает в себя эту информацию, а также базовую ошибку синтаксического анализатора:

```go
doc, err := html.Parse(resp.Body)
resp.Body.Close()
if err != nil {
return nil, fmt.Errorf("Анализ %s как HTML: %v", url, err)
}
```

Функция fmt.Errorf форматирует сообщение об ошибке, используя функцию fmt.Sprintf, и возвращает новое значение error.

## 2.

Для ошибок, которые представляют преходящие или непредсказуемые проблемы, может иметь смысл повторить сбойную операцию,
возможно, с задержкой между попытками, и, вероятно, с ограничением, накладываемым на количество попыток или на время,
которое можно затратить на выполнение попыток.

```go
func WaitForServer(url string) error {
    const timeout = 1 * time.Minute
    deadline := time.Now().Add(timeout)
    for tries := 0; time.Now().Before(deadline); tries++ {
        _, err := http.Head(url)
        if err == nil {
            return nil // Успешное соединение
        }
        log.Printf("Сервер не отвечает (%s)j повтор...", err)
        time.Sleep(time.Second << uint(tries)) // Увеличение задержки
}
return fmt.Errorf("Сервер %s не отвечает; время %s ", url, timeout)
}
```