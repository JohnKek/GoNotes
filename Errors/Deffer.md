Defer позволяет отложить выполнение кода до момента завершения функции. Обычно его используют, чтобы освободить ресурсы, выделенные внутри функции (открытые файлы, соединения и тому подобное). В питоне в таких случаях применяют контекстные менеджеры, а в js конструкцию try-finally.
Инструкция defer часто используется с такими парными операциями, как открытие и закрытие, подключение и отключение или блокировка и разблокирование — для гарантии освобождения ресурсов во всех случаях, независимо от того, насколько сложен поток управления. Правильное место инструкции defer, которая освобождает ресурс, — сразу же после того, как ресурс был успешно захвачен.
Допустим, мы хотим создать файл, записать в него что-то и закрыть. Вот как поможет defer:
```go
func main() {
f, err := createFile("/tmp/defer.txt")
if err != nil {
fmt.Println("Error creating file:", err)
return
}

    defer closeFile(f)    // (1)

    if err := writeFile(f); err != nil {
        fmt.Println("Error writing to file:", err)
        return            // (2)
    }

    fmt.Println("Success!")
}
```
После того как файл открыт, мы с помощью defer указываем, что необходимо вызвать отложенную функцию closeFile() ➊. Она выполнится в самом конце, при завершении функции main(). Причем отложенная функция отработает в любом случае — даже если во время записи в файл произошла ошибка и сработал досрочный return ➋.

Допустим, создание файла пройдет успешно, а при записи случится ошибка:
```go
func createFile(name string) (*os.File, error) {
fmt.Println("Creating file...")
// ...
}

func writeFile(f *os.File) error {
fmt.Println("Writing to file...")
// эмулируем неминуемую ошибку
return fmt.Errorf("oh no, it all went wrong!")
}

func closeFile(f *os.File) {
fmt.Println("Closing file...")
// ...
}
//closeFile() все равно отработает:
```
Creating file...
Writing to file...
Error writing to file: oh no, it all went wrong!
Closing file...

Инструкция defer может также использоваться для пары отладочных записей о входе в некоторую функцию и выходе из нее. Показанная ниже функция BigSlowOperation немедленно вызывает функцию trace, которая выполняет запись о входе в функцию и возвращает значение-функцию, которая при вызове выполняет запись о выходе из функции. Таким образом, с помощью отложенного вызова возвращаемой функции мы можем выполнять запись о входе в функцию и выходе из нее в одной инструкции и даже передавать между этими двумя действиями значения, например время начала работы функции. Но не забывайте о завершающей паре скобок в инструкции defer, иначе “входное’4 действие будет выполнено на выходе из функции, а “выходное’' не будет выполнено вовсе!
```go
func bigSlowOperation() {
defer trace("bigSlowOperation")() // He забывайте о скобках!
// ... длительная работа ...
time.Sleep(10 * time.Second) // Имитация долгой работы
}
func trace(msg string) func() { 
	start := time.Now() 
	log.Printf("вход в %s", msg)
    return funcQ { log.Printf("выход из %s (%s)", msg, time.Since(start)) }
}
```
Присвоив имя ее результирующей переменной и добавив инструкцию defer, мы можем заставить функцию выводить свои аргументы и результат при каждом вызове:
```go
func double(x int) (result int) {
defer func() 
{ fmt.Printf("double(%d) = %d\n,,J x, result) }() 
return x + x
}
_ = double(4)
// Вывод:
// "double(4) = 8”
```

Отложенная анонимная функция может даже изменять значения, которые возвращает охватывающая функция:
```go
func triple(x int) (result int) { 
	defer func() { result += x }() 
	return double(x)
}
```
