Рефлексия обеспечивается пакетом reflect. Он определяет два важных типа, Туре и Value. Туре представляет собой тип Go.
Это интерфейс со многими методами для того, чтобы можно было различать типы и проверять их компоненты, такие как поля
структуры или параметры функции. Единственная реализация reflect. Туре представляет собой дескриптор типа (раздел 7.5),
ту же сущность, что и идентифицирующая динамический тип значения интерфейса.

Функция reflect.TypeOf принимает любой interface{} и возвращает его динамический тип как reflect .Туре:

```go
t := reflect.TypeOf(3) // reflect.Type
fmt.Println(t.String()) // "int"
fmt.Println(t)
```

Вспомните из раздела7.5

Поскольку reflect .TypeOf возвращает динамический тип значения интерфейса, этот вызов всегда возвращает конкретный тип.
Так что, например, приведенный ниже код выводит ”*os. File", а не "io. Writer". Позже мы увидим, что reflect. Туре в
состоянии представлять и интерфейсные типы:

```go
var w io.Writer = os.Stdout
fmt.Println(reflect.TypeOf(w)) 
```

Обратите внимание, что reflect. Ту ре удовлетворяет интерфейсу fmt. Stringer. Поскольку знать динамический тип значения
интерфейса полезно для отладки и записи в журнал, fmt.Printf предоставляет соответствующее сокращение %Т, которое
использует reflect .TypeOf во внутренней реализации:

```go
fmt.Printf("%Т\п", 3) // "int”
```

Другим важным типом в пакете reflect является Value, reflect .Value может хранить значение любого типа. Функция reflect
.ValueOf принимает любой interface{} и возвращает значение reflect .Value, содержащее динамическое значение интерфейса.
Как и в случае reflect .TypeOf, результат reflect .ValueOf всегда конкретен, но reflect .Value может хранить и значения
интерфейса:

```go
v := reflect.ValueOf(3) // reflect.Value
fmt.Println(v) // "3"
fmt.Printf("%v\n", v) // "З"
fmt.Println(v.String()) // Примечание: "<int Value>"

```

Обратной к reflect .ValueOf операцией является метод reflect .Value. Interface. Он возвращает interface{}, хранящий то
же самое конкретное значение, что и reflect.Value:

```go
v := reflect.ValueOf(3) // reflect.Value
x := v.InterfaceQ 11 interface{}
i := x.(int) // int
fmt.Printf("%d\n", i) // "3"
```