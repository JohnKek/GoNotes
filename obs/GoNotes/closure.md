
Go поддерживает анонимные функции, которые могут образовывать замыкания. Анонимные функции полезны, когда вы хотите определить встроенную функцию, не называя ее.

Run codeCopy code
package main
import "fmt"
Эта функция intSeq возвращает другую функцию, которую мы анонимно определяем в теле intSeq. Возвращенная функция присваивается в переменную i, чтобы сформировать замыкание.

```go
func intSeq() func() int {
    i := 0
    return func() int {
        i++
        return i
    }
}
func main() {
    nextInt := intSeq()
    fmt.Println(nextInt())
    fmt.Println(nextInt())
    fmt.Println(nextInt())
    newInts := intSeq()
    fmt.Println(newInts())
}
```
Мы вызываем intSeq, присваивая результат (функцию) nextInt.Это значение функции фиксирует свое собственное значение i, которое будет обновляться каждый раз, когда мы вызываем nextInt.

Посмотрите, что происходит при вызове nextInt несколько раз.

Чтобы подтвердить, что состояние является уникальным для этой конкретной функции, создайте и протестируйте новую.
$ go run closures.go
1
2
3
1
Последняя особенность функций, которые мы сейчас рассмотрим, - это рекурсия.

Следующий пример: Рекурсия (Recursion).