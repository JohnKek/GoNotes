Еще одним способом создания переменной является применение встроенной функции new. Выражение new(T) создает
неименованную переменную типа Т, инициализирует ее нулевым значением типа Т и возвращает ее адрес, который представляет
собой значение типа *Т.

```
р := new(int) // р, имеющий тип *int, указывает на неименованную // переменную типа int fmt.Println(*p) // "0м
*р = 2 // Устанавливает значение этой переменной равным 2
fmt.Println(*p) // "2"
```

Переменная, созданная с помощью new, ничем не отличается от обычной локальной переменной, у которой берется адрес, за
исключением того, что нет необходимости придумывать (и объявлять) ее имя и можно использовать в выражении new(T). Таким
образом, new является только лишь синтаксическим удобством, но не фундаментальным понятием: две приведенные ниже функции
newlnt имеют идентичное поведение.

```
func newlnt() *int {
    return new(int)
}

func newInt() *int {
    var dummy int
    return &dummy
}
```

Каждый вызов new возвращает отличную от предыдущих переменную с уникальным адресом:
```
р := new(int) q := new(int)
fmt.Println(p == q) // "false"
```
Существует одно исключение из этого правила: две переменные, тип которых не несет никакой информации, а потому имеющие нулевой размер, такие как struct{} или [0]int, могут, в зависимости от реализации, иметь один и тот же адрес.
Функция new используется относительно редко, поскольку наиболее распространены неименованные переменные структурных типов, для которых имеется более гибкий литеральный синтаксис (раздел 4.4.1).
Поскольку new является предопределенной функцией, а не ключевым словом, это имя можно переопределить для чего-то иного в функции, например:
```
func delta(old, new int) int { return new - old }
```
Конечно, внутри delta встроенная функция new недоступна.