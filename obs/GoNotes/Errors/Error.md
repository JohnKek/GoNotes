В Go нет исключений и блока try-catch, как в питоне или js. Вместо этого функции явно возвращают ошибку отдельным значением. Благодаря этому ошибки невозможно проигнорировать, а разработчики продумывают поведение программы в случае проблем.

Ошибки принято возвращать последним значением с интерфейсным типом error:

```go
func sqrt(x float64) (float64, error) {
    if x < 0 {
    return 0, errors.New("expect x >= 0")
    }
    // `nil` в качестве ошибки указывает, что ошибок не было.
    return math.Sqrt(x), nil
}
```
Проверим работу sqrt() на положительном и отрицательном значениях. Обратите внимание, как мы получаем результат и проверяем ошибку внутри условия if — это стандартная практика в Go.
```go
for _, x := range []float64{49, -49} {
    if res, err := sqrt(x); err != nil {
        fmt.Printf("sqrt(%v) failed: %v\n", x, err)
    } else {
        fmt.Printf("sqrt(%v) = %v\n", x, res)
    }
}
// sqrt(49) = 7
// sqrt(-49) failed: expect x >= 0
```