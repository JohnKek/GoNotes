### Транзакции

Транзакция объединяет несколько запросов к базе данных в единый логический блок, который либо выполняется целиком (если все запросы отработали успешно), либо не выполняется вообще (если хотя бы один запрос сломался). Чаще всего транзакции используют, чтобы гарантировать, что база не останется в «противоречивом» состоянии при ошибке.

Классический пример — перенос денег с одного счета на другой. Допустим, есть Алиса и Боб, у них на счетах по 100 монет:

```http
┌────┬───────┬─────────┐
│ id │ name  │ balance │
├────┼───────┼─────────┤
│ 1  │ Alice │ 100     │
│ 2  │ Bob   │ 100     │
└────┴───────┴─────────┘
```

Хотим перенести 50 монет от Алисы к Бобу, чтобы получилось так:

```go
┌────┬───────┬─────────┐
│ id │ name  │ balance │
├────┼───────┼─────────┤
│ 1  │ Alice │ 50      │
│ 2  │ Bob   │ 150     │
└────┴───────┴─────────┘
```

Для этого придется выполнить два запроса:

```sql
update accounts set balance = balance - 50 where id = 1; 
update accounts set balance = balance + 50 where id = 2;
```

Если первый запрос успешно выполнится, а второй сломается, то 50 монет пропадут у Алисы, но не появятся у Боба. Именно от таких ситуаций и защищают транзакции:

```sql
begin transaction; 
update accounts set balance = balance - 50 where id = 1; 
update accounts set balance = balance + 50 where id = 2; 
commit transaction;
```

Теперь, если второй update сломается, то транзакция откатится целиком, и база останется в исходном состоянии.

Повторим ситуацию на Go. Сценарий переноса монет выглядит так:

```go
db, err := sql.Open("sqlite3", "accounts.db")
// ...
const (
    aliceID = 1
    bobID   = 2
    amount   = 50
)
err = transfer(db, aliceID, bobID, amount)
if err != nil {
    panic(err)
}
```

Функция `transfer()` отвечает за перенос монет в транзакции:

```go
// transfer переносит amount денег с счета fromID на счет toID
func transfer(db *sql.DB, fromID, toID, amount int) error {
const query = "update accounts set balance = balance + ? where id = ?"

tx, err := db.Begin()    // (1)
if err != nil {
return err
}
defer tx.Rollback()      // (2)

_, err = tx.Exec(query, -amount, fromID)  // (3)
if err != nil {
return err
}
_, err = tx.Exec(query, amount, toID)     // (4)
if err != nil {
return err
}
return tx.Commit()                         // (5)
}
```

Вот что здесь происходит:

1.  Через `DB.Begin()` открываем транзакцию и получаем указатель на нее `sql.Tx`. Все дальнейшие действия будем выполнять на транзакции `tx`, а не на базе `db`.
2.  Через `Tx.Rollback()` гарантируем, что транзакция будет откачена при ошибке.
3.  Через `Tx.Exec()` забираем монеты с исходного счета.
4.  Через `Tx.Exec()` зачисляем монеты на целевой счет.
5.  Через `Tx.Commit()` фиксируем транзакцию в базе.

Может возникнуть вопрос: но ведь `Rollback()` выполнится в любом случае, в том числе после успешного `Commit()`. Получается, мы откатываем транзакцию после того, как зафиксировали ее? На самом деле, нет: зафиксированную транзакцию откатить невозможно. `Rollback()` же специально реализован так, чтобы даже не пытаться ничего сделать, если транзакция уже зафиксирована. Поэтому его безопасно вызывать через `defer`.

`sql.Tx` предоставляет методы, которые мы уже видели на `sql.DB`:

```go
Exec(query string, args ...any) (Result, error) Query(query string, args ...any) (*Rows, error) QueryRow(query string, args ...any) *Row Prepare(query string) (*Stmt, error)
```

После старта транзакции используйте именно методы `sql.Tx`, а не `sql.DB` — только так вы гарантируете, что запрос выполнится внутри открытой транзакции.

Благодаря `Tx.Prepare()` можно подготовить выражение `sql.Stmt` и использовать его внутри транзакции, аналогично тому, как мы это делали с `sql.DB` на предыдущем шаге. Кроме того, `Tx` умеет взять существующее подготовленное выражение и «перенести» его внутрь транзакции:

```go
// вне транзакции stmt, err := db.Prepare(query) // ... // внутри транзакции txStmt := tx.Stmt(stmt) // запрос выполнится внутри транзакции txStmt.Exec(vals...)
```

Если `Stmt` создано внутри транзакции — явно закрывать его не требуется (в отличие от `Stmt`, созданных через `DB.Prepare()`). Транзакция закрывает такие выражения автоматически при фиксации или откате.

[песочница](https://go.dev/play/p/9oBu1YvSvsq)

> В песочнице подключение к базе не работает. Запускайте локально, если хотите попробовать.

### Уровень изоляции

У транзакций существует так называемый _уровень изоляции_ (isolation level). Он определяет, насколько транзакция «защищена» от изменений, которые внесли в базу другие транзакции, работающие одновременно с ней.

В идеальном мире транзакция была бы полностью изолирована (такой уровень существует, он называется serializable). Но чтобы обеспечить такой уровень изоляции, СУБД придется выполнять все транзакции строго последовательно. Это может критически ухудшить производительность при большом количестве одновременных транзакций. Поэтому обычно используют не serializable, а более слабые уровни изоляции.

По умолчанию транзакция использует тот уровень изоляции, который настроен в СУБД. Но его можно изменить, если вместо `DB.Begin()` использовать метод `DB.BeginTx()`. О нем — на следующем шаге.

В целом, тема изоляции транзакций выходит за рамки курса, так что если хотите узнать о них больше — посмотрите [документацию PostgreSQL](https://postgrespro.ru/docs/postgresql/15/transaction-iso).