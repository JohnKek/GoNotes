1) сообщение для приветствующего, 2) приветствующий, который передает это сообщение, и 3) событие, которое начинается с приветствия приветствующим гостей. В этом дизайне у нас есть три `struct`типа:
```go
type Message string
type Greeter struct {
    // ... TBD
}
type Event struct {
    // ... TBD
}
```
Тип `Message`просто оборачивает строку. Сейчас мы создадим простой инициализатор, который всегда возвращает жестко закодированное сообщение:
```go
func NewMessage() Message {
    return Message("Hi there!")
}
```
Нам `Greeter`понадобится ссылка на `Message`. Так что давайте создадим инициализатор `Greeter`и для нашего .
```go
func NewGreeter(m Message) Greeter {
    return Greeter{Message: m}
}

type Greeter struct {
    Message Message // <- adding a Message field
}
```

В инициализаторе мы назначаем `Message`поле `Greeter`. Теперь мы можем использовать `Message`при создании `Greet`метода для `Greeter`:
```go
func (g Greeter) Greet() Message {
    return g.Message
}
```

Далее нам понадобится наш `Event`, `Greeter`поэтому мы создадим инициализатор и для него.
```go
func NewEvent(g Greeter) Event {
    return Event{Greeter: g}
}

type Event struct {
    Greeter Greeter // <- adding a Greeter field
}
```
Затем мы добавляем метод для запуска `Event`:
```go
func (e Event) Start() {
    msg := e.Greeter.Greet()
    fmt.Println(msg)
}
```

Этот `Start`метод составляет основу нашего небольшого приложения: он сообщает приветствующему о необходимости произнести приветствие, а затем выводит это сообщение на экран.

Теперь, когда все компоненты нашего приложения готовы, давайте посмотрим, что нужно для инициализации всех компонентов без использования Wire. Наша основная функция будет выглядеть так:

Сначала мы создаем сообщение, затем мы создаем приветствие с этим сообщением, и, наконец, мы создаем событие с этим приветствием. После завершения инициализации мы готовы начать наше событие.

Мы используем принцип проектирования [внедрения зависимостей](https://stackoverflow.com/questions/130794/what-is-dependency-injection) . На практике это означает, что мы передаем все, что нужно каждому компоненту. Этот стиль проектирования позволяет писать легко тестируемый код и легко заменять одну зависимость другой.
