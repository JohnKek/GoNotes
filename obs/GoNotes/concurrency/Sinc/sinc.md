Горутины, каналы и селект — основные строительные блоки многозадачных программ на Go. Но не единственные. На этом уроке посмотрим на некоторые инструменты, которые предоставляет пакет `sync`.

### Группа ожидания (sync.WaitGroup)

С группы ожидания `[sync.WaitGroup](https://pkg.go.dev/sync#WaitGroup)` мы начали этот модуль. Давайте освежим:

```go
func main() {
var wg sync.WaitGroup

wg.Add(1)
go say(&wg, 1, "go is awesome")

wg.Add(1)
go say(&wg, 2, "cats are cute")

wg.Wait()
}

func say(wg *sync.WaitGroup, id int, phrase string) {
for _, word := range strings.Fields(phrase) {
time.Sleep(50 * time.Millisecond)
fmt.Printf("Worker #%d says: %s...\n", id, word)
}
wg.Done()
}
```

```no
Worker #1 says: go...
Worker #2 says: cats...
Worker #1 says: is...
Worker #2 says: are...
Worker #1 says: awesome...
Worker #2 says: cute...
```

Группа ожидания позволяет дождаться, пока отработают запущенные горутины. Внутри у нее счетчик, который мы увеличиваем методом `Add()` и уменьшаем методом `Done()`. Метод `Wait()` блокирует выполнение горутины, пока счетчик не достигнет 0.

Пара важных нюансов:

-   `Add()` вызывают не в запускаемой горутине, а в основной — той же, где затем будет `Wait()`. Иначе `Wait()` успел бы отработать до `Add()`. Он увидел бы, что счетчик пуст, после чего основная горутина завершилась.
-   Группу ожидания всегда передают по ссылке. Если передать ее по значению, запускаемая горутина получит копию с отдельным счетчиком. Мы же хотим использовать общий экземпляр группы, чтобы `Add()`, `Done()` и `Wait()` работали с одним и тем же счетчиком.

[песочница](https://go.dev/play/p/E9y-cIOAoAO)



### Одновременная модификация

До сих пор горутины у нас не лезли в дела друг друга. Чтобы обмениваться данными, они использовали каналы — это безопасно. Но что будет, если обращаться к «обычным» объектам из нескольких горутин? Проверим.

Напишем программу, которая считает частоту слов:

```go
func main() {
rand.Seed(0)

in := generate(100, 3)
counter := map[string]int{}

var wg sync.WaitGroup
wg.Add(2)

go count(&wg, in, counter)
go count(&wg, in, counter)

wg.Wait()

fmt.Println(counter)
}

// считает частоты слов
func count(wg *sync.WaitGroup, in <-chan string, counter map[string]int) {
defer wg.Done()
for word := range in {
counter[word]++
}
}

// генерит слова и отправляет их в канал
func generate(nWords, wordLen int) <-chan string {
// ...
}
```

`generate()` генерит слова и отправляет их в канал `in`. `main()` создает пустую карту `counter` и передает ее двум горутинам `count()`. `count()` читает из канала `in` и заполняет карту частотами слов. В результате в `counter` для каждого слова должна быть его частота.

Запустим:

```no
$ go run counter.go map[cec:1 ... nol:2 not:3 ... tut:1]
```

И еще раз, на всякий случай:

```no
$ go run counter.go fatal error: concurrent map writes
```

Ошибка.

Go не нравится одновременный доступ к карте из нескольких горутин. На первый взгляд, это странно. Вот единственная операция, которую горутина `count()` выполняет с картой:

```go
counter[word]++
```

Выглядит как атомарное действие. Почему бы не выполнять его из нескольких горутин?

Проблема в том, что действие только выглядит атомарным. Операция «увеличить значение в карте по ключу» состоит из цепочки более мелких действий. Если часть этих действий выполнит одна горутина, а часть другая — целостность карты будет нарушена. О чем Go нам и сообщает.

[песочница](https://go.dev/play/p/xYDGV0x_5kM)


### Мьютекс (sync.Mutex)

В пакете `sync` есть специальный инструмент, который защищает общие данные и участки кода (такие участки называются _критической секцией_) от одновременного доступа. Этот инструмент — _мьютекс_ `[sync.Mutex](https://pkg.go.dev/sync#Mutex)`:

```go
func main() {
in := generate(100, 3)
counter := map[string]int{}

var wg sync.WaitGroup
wg.Add(2)

var lock sync.Mutex    // (1)
go count(&wg, &lock, in, counter)
go count(&wg, &lock, in, counter)

wg.Wait()

fmt.Println(counter)
}

// считает частоты слов
func count(wg *sync.WaitGroup, lock *sync.Mutex, in <-chan string, counter map[string]int) {
defer wg.Done()
for word := range in {
lock.Lock()       // (2)
counter[word]++
lock.Unlock()     // (3)
```

Мьютекс гарантирует, что участок кода между `Lock()` и `Unlock()` выполняется только одной горутиной в каждый момент времени. Работает это так:

1.  В ➊ мы создаем мьютекс и передаем его обеим горутинам `count()`.
2.  В ➋ первая горутина «запирает» мьютекс, после чего выполняет `counter[word]++`.
3.  Если в этот момент вторая горутина дойдет до ➋, то она заблокируется, потому что мьютекс «заперт».
4.  В ➌ первая горутина «отпирает» мьютекс.
5.  Теперь вторая горутина разблокируется. Она, в свою очередь, запирает мьютекс и выполняет `counter[word]++`.

> В русскоязычной литературе принято переводить lock как «блокировать» и unlock как «разблокировать». Я буду переводить их как «запирать» и «отпирать», чтобы не было путаницы с блокированием и разблокированием горутин (в англоязычной литературе block и unblock).

Таким образом, `counter[word]++` не может выполняться несколькими горутинами одновременно. Теперь карта не пострадает:

```bash
$ go run -race counter.go map[cec:1 ... nol:2 not:3 ... tut:1]
```

Мьютекс используют в следующих ситуациях:

-   Если несколько горутин модифицируют одни и те же данные.
-   Если одна горутина модифицирует данные, а несколько читают.

Если все горутины только читают данные, мьютекс не нужен.

В отличие от некоторых других языков, мьютекс в Go не реентерабельный (non-reentrant). Если горутина вызовет `Lock()` на ей же запертом мьютексе — она заблокируется:

```go
var lock sync.Mutex lock.Lock() // ok lock.Lock() // fatal error: all goroutines are asleep - deadlock!
```

Это осложняет жизнь любителям использовать мьютексы в рекурсивных функциях (что в любом случае так себе идея).

Как и группа ожидания, мьютекс обладает внутренним состоянием, поэтому передавать его следует только по ссылке.

[песочница](https://go.dev/play/p/aHxU39eWr7u)